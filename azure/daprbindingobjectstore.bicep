extension kubernetes with {
  kubeConfig: ''
  namespace: context.runtime.kubernetes.namespace
} as k8s
extension radius

@description('Information about what resource is calling this Recipe. Generated by Radius. For more information visit https://docs.radapp.dev/operations/custom-recipes/')
param context object

@description('Name of the storage account to use')
param accountName string

@description('Optional storage account key as a secret reference to a Dapr secret store. If this is not provided, either the worload identity will be used or the account key will be fetched from the storage account reference.')
param accountKeyRef SecretStoreReference = {
  secretStoreName: ''
  secretKeyRef: {
    name: 'accountKey'
    key: 'accountKey'
  }
}

@description('Wether to use workload identity to access the storage account. Default is false')
param useWorkloadIdentity bool = false

@description('Name of the bucket to create in the S3-compatible object store. Default is mybucket')
param bucket string = 'mybucket'

@description('Encode binary files content in base64 before sending it to the application. Default is true')
param decodeBase64 bool = true



resource storageAccount 'Microsoft.Storage/storageAccounts@2023-05-01' existing = {
  name: accountName
}

var accountKeyMetadata = useWorkloadIdentity
  // If workload identity is used, the account key is not needed. 
  ? {}
  // If workload identity is not used, the account key can be provided as a secret or a value.
  // As a secret, the secret store name must be provided.
  : !empty(accountKeyRef.secretStoreName)
      ? {
          name: 'accountKey'
          secretKeyRef: accountKeyRef.secretKeyRef
        }
      // As a value, the account key can be fetched from the storage account reference.
      : {
          name: 'accountKey'
          value: storageAccount.listKeys().keys[0].value
        }

// The secret store name is only needed if the account key is provided as a secret.
var daprAuthProperty = !empty(accountKeyRef.secretKeyRef)
  ? { secretStore: accountKeyRef.secretStoreName }
  : { secretStore: '' }


var daprType = 'bindings.azure.blobstorage'
var daprVersion = 'v1'
resource daprComponent 'dapr.io/Component@v1alpha1' = {
  auth: daprAuthProperty
  metadata: {
    name: context.resource.name
  }
  spec: {
    type: daprType
    version: daprVersion
    metadata: concat(
      [
        {
          name: 'accountName'
          value: storageAccount.name
        }
        {
          name: 'containerName'
          value: bucket
        }
        {
          name: 'decodeBase64'
          value: decodeBase64
        }
      ],
      [accountKeyMetadata]
    )
  }
}

@description('Reference to a secret in a Dapr secret store')
type SecretStoreReference = {
  @description('Name of the secret store')
  secretStoreName: string
  @description('Reference to a key in the secret store')
  secretKeyRef: {
    @description('Name of the secret')
    name: string
    @description('Key of the secret if it is a dictionary')
    key: string
  }
}

output result object = {
  // This workaround is needed because the deployment engine omits Kubernetes resources from its output.
  // This allows Kubernetes resources to be cleaned up when the resource is deleted.
  // Once this gap is addressed, users won't need to do this.
  resources: [
    '/planes/kubernetes/local/namespaces/${daprComponent.metadata.namespace}/providers/dapr.io/Component/${daprComponent.metadata.name}'
  ]
  values: {
    type: daprType
    version: daprVersion
    metadata: daprComponent.spec.metadata
  }
}
